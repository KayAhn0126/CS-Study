# Process Management

## 🍎 프로세스 생성
### 📖 프로세스 생성에 관한 기본적 정의
- 부모 프로세스가 자식 프로세스 생성 (여럿을 낳을 수 있다)
- 프로세스의 트리(계층 구조) 형성
- 프로세스는 자원을 필요로 한다.
    - 운영체제로부터 받는다.
    - 경우에 따라 자원을 공유하기도 하지만, 보통적인 상황에서는 공유하지 않는다.
    - 부모, 자식 프로세스라고 부르긴 하지만 서로 CPU를 얻기 위해서 경쟁하는 사이(남)라고 생각하면 된다.
- 프로세스의 수행에 있어서 부모와 자식이 공존하면서 각자 수행되는 모델이 있고, 자식이 종료(terminate)될 때까지 부모가 기다리는(wait) 모델이 있다.
    - 여기서 wait은 blocked 상태

### 📖 실제 프로세스 생성 과정
- **부모 프로세스의 주소공간을 자식 프로세스가 그대로 복사를 한다** -> fork()
- **자식은 그 주소공간에 새로운 프로그램을 올린다**(덮어 씌운다). -> exec()
- 유닉스의 예
    - fork()라는 시스템 콜이 새로운 프로세스를 생성
        - 부모 프로세스 주소공간을 그대로 복사(OS data except PID + binary) 후 할당
    - fork 시스템 콜 다음에 이어지는 exec() 시스템 콜을 통해 새로운 프로그램을 메모리에 올림
- 복사하는 fork()와 exec()은 같이 실행되어야 하는것은 아니다. 각각 실행되어 fork로 주소공간만 복사할 수 있고, exec()로 주소공간에 새로운 프로그램을 덮어씌워 메모리에 올릴수도 있다.
- 사용자 프로그램(프로세스)가 마음대로 복사하는것이 아니다. fork(), exec()은 시스템 콜이라고 했다. 즉, **운영체제에게 자식을 낳아달라고 부탁 해서 운영체제가 대신 자식 프로세스를 낳아주는 개념**이라고 생각하면 된다.

## 🍎 프로세스 종료
### 📖 정의
- 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌(exit)
    - exit()이라는 시스템 콜을 하면 프로세스가 종료된다.
- **프로세스가 종료될때 자식이 부모에게 data를 보낸다(wait() 시스템 콜을 통해서 data 전달)**
    - 프로세스의 세계에서는 자식이 부모보다 먼저 종료된다.
- **프로세스의 각종 자원들이 운영체제에게 반납됨**
### 📖 자발적 종료, 비자발적 종료
- 자발적으로 프로세스가 종료가 될때는 exit() 시스템콜을 해주고 비 자발적으로 프로세스가 종료되는 경우는 abort라고 한다.
- 위에서 자발적으로 종료되는 경우를 다뤘으니 비자발적으로 종료되는 경우를 살펴보자.
- 즉, 부모 프로세스가 자식 프로세스를 종료 시키는 경우이다.
    - 자식이 할당 자원의 한계치를 넘어섬
        - 너무 많은 자원을 소모하면 종료시킴
    - 자식에게 할당된 테스크가 더 이상 필요하지 않음
        - 자식이 더 이상 필요없으면 종료시킴 
    - 부모가 종료(exit)하는 경우
        - 운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않는다.
        - **프로세스 세계에서는 자식이 부모보다 먼저 종료되어야 한다고 했다.** 하지만 어떤 경우에는 부모가 먼저 종료되는데 이때는 부모 프로세스를 통해 생성된 자식 프로세스(들)을 먼저 다 종료 시킨 후에 부모 프로세스가 종료된다.

## 🍎 fork() 시스템 콜
### 📖 fork() 시스템 콜 실행 시 발생하는 일
```c=
int main()
{
    int pid;
    pid = fork();
    if (pid == 0)    /* this is child */
        printf("\n Hello, I am child!");
    else if (pid > 0) /* this is parent */
        printf("\n Hello, I am parent!");
}
```
- C언어를 사용해 자식 프로세스를 생성하는 코드이다.
- 코드의 4번 라인은 자식 프로세스를 생성하겠다는 의미이다.
- 4번라인이 끝나면 자식 프로세스가 생성되는데 자식 프로세스는 부모 프로세스의 문맥을 모두 복사해서 생성되기 때문에, 4번라인을 실행했다는 문맥을 가지고 생성되는것이다. 즉, 부모, 자식 프로세스 둘 다 5번라인을 실행할 차례이다.

### 📖 부모 프로세스와 자식 프로세스 구별법
- 자식 프로세스는 부모 프로세스의 문맥을 그대로 복사해서 생성하는데 그럼 자식 프로세스가 "내가 부모 프로세스다!"라고 할 수 있는 상황이다.
- 위의 코드를 보면 pid = fork()라고 되어있다.
- fork() 시스템 콜을 실행한 후의 반환값으로 자식 프로세스인지 부모 프로세스인지 구별할 수 있다.
- 부모 프로세스는 fork()의 반환값이 양수
    - 더 정확히는 자식 프로세스의 PID
- 자식 프로세스는 fork()의 반환값이 0

## 🍎 exec() 시스템 콜
- 위는 같은 코드를 두개의 프로세스가 실행하는 설명이었다.
- 자식 프로세스를 생성하고 다른 프로그램을 올리는 코드를 보자.
- exec() 시스템 콜은 어떤 프로그램을 완전히 새로운 프로세스로 태어나게 하는 역할을 해준다.
- 아래의 코드로 exec() 시스템 콜이 어떻게 사용되는지 보자.
```c=
int main()
{
    int pid;
    pid = fork();
    if (pid == 0)
        printf("\n I am child!\n");
        execlp("/bin/date", "/bin/date", (char *) 0);
        printf("bye!")
    else if (pid > 0)
        printf("\n I am parent!\n")
}
```
- execlp()를 만나면 인자에 있는 경로의 프로그램을 자식 프로세스에게 덮어씌운다.
- 자식 프로세스는 덮어 씌워진 프로그램의 처음부터 실행. 갓난아기로 태어난것과 같다.
- fork()는 인간 자체를 복사하는것과 같고, execlp()는 갓난아기를 만드는것과 같다.
- 대신 exec()는 갓난아기(새로운 프로그램)으로 실행되기 때문에 이전 기억이 없다. 즉 7번라인(새로운 프로그램으로 프로세스를 덮어씌우는 행위) 이후 8번 라인은 실행이 되지 않는다.

## 🍎 wait() 시스템 콜
- 프로세스 A가 wait() 시스템 콜을 호출하면
    - 커널은 child가 종료될 때까지 프로세스 A를 sleep 시킨다(block 상태)
    - Child process가 종료되면 커널은 프로세스 A를 깨운다(ready 상태)

## 🍎 exit() 시스템 콜
- 자발적 종료(보통의 상황)
    - 마지막 statement 수행 후 exit() 시스템 콜을 통해 종료.
    - 프로그램에 명시적으로 적어주지 않아도 main 함수가 리턴되는 위치에 컴파일러가 넣어줌
- 비자발적 종료
    - 부모 프로세스가 자식 프로세스를 강제로 종료시킴
        - 자식 프로세스가 한계치를 넘어서는 자원 요청
        - 자식에게 할당된 테스크가 더 이상 필요하지 않음
    - 키보드로 kill, break등을 입력한 경우
        - 예) Control + C
    - 부모가 종료하는 경우
        - 부모 프로세스가 종료하기 전에 자식들이 먼저 종료됨

## 🍎 프로세스와 관련한 시스템 콜 정리
- fork()
    - create a child (copy)
- exec()
    - overlay new program
- wait()
    - sleep until child is done
- exit()
    - frees all the resources, notify parent

## 🍎 프로세스 간 협력
- 독립적 프로세스(Independent process)
    - 프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못함
- 협력 프로세스(Cooperating process)
    - 프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있음
- **프로세스 간 협력 메커니즘**(IPC: Interprocess Communication)
    - 메세지를 전달하는 방법
        - message passing: 커널을 통해 메시지 전달
        - 원칙적으로 프로세스끼리는 메시지를 전달할 수 없다. 중간에 커널이 메신저 역할을 해준다.
    - 주소 공간을 공유하는 방법
        - shared memory: 서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 shared memory 메커니즘이 있음
        - thread: thread는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵지만 동일한 process를 구성하는 thread들 간에는 주소 공간을 공유하므로 협력이 가능하다.
