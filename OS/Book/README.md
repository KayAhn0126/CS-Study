# 운영체제와 정보기술의 원리 책 정리
- 책에서 중요한 키워드만 각각 정리

## 🍎 물리적 메모리를 관리하는 방식(p.61)
- 고정분할
    - 물리적 메모리를 몇 개의 분할로 미리 나누어 관리한다.
    - 융통성이 없고, 분할된 메모리 보다 큰 프로그램은 적재 불가.
    - 내부조각(분할된 크기보다 작은 프로그램이 적재될때 남는 공간)이 생기는데 이는 다른 프로그램에 할당될 수 없으므로 비효율적.
- 가변분할
    - 분할의 크기와 개수가 동적으로 변하므로 기술적 관리 기법이 필요하다.
    - 고정분할처럼 내부조각은 발생하지 않지만 외부조각이 발생할 수 있다.
    - 외부조각(프로그램에 할당 되지는 않았지만 그 크기가 작아 프로그램을 올리지 못하는 메모리 영역)이 생길수도 있는데 이 또한 비효율적.
- 가상메모리
    - 현대의 범용 컴퓨터 환경에서 가장 널리 사용되는 메모리 관리 기법.
    - 물리적 메모리보다 더 큰 프로그램이 실행되는 것을 지원한다.
    - 모든 프로그램은 물리적 메모리와는 독립적으로 0번지부터 시작하는 자신만의 가상메모리 주소를 갖는다.
    - 운영체제는 이 가상메모리의 주소를 물리적 메모리 주소로 매핑(mapping)하는 기술을 이용해 주소를 변환시킨 후 프로그램을 물리적 메모리에 올리게 된다.
    - 가상메모리 기법에서는 물리적 메모리의 크기와 상관 없이, 사용할 수 있는 메모리의 크기가 충분히 크다고 가정하고 프로그램을 개발할 수 있는데, 원리는 다음과 같다.
    - 프로그램의 전체 크기가 2GByte일지라도 전체가 항상 동시에 사용되는 것은 아니다. 그러므로 현재 사용되고 있는 부분만 메모리에 올리고, 나머지는 하드디스크와 같은 보조기억장치에 저장해두었다가 필요할 때 적재하는 방식을 취한다.
    - 이때 사용되는 보조기억장치의 영역을 스왑영역(swap)이라고 한다.
    - 프로그램을 구성하는 가상메모리 주소 공간은 페이지(page)라는 동일한 크기의 작은 단위로 나뉘어 물리적 메모리와 스왑 영역에 일부분씩 저장된다.
    - 이렇게 동일한 단위로 메모리를 나누는 기법을 페이징(paging)기법 이라고 한다.

## 🍎 보조기억장치의 두 가지 용도(p.82)
- 파일 시스템용
    - 보조기억장치의 본 용도
- 주기억장치의 연장 공간인 스왑 영역(swap area)
    - 다수의 프로그램이 메모리에 올라가 동시에 수행되는 현대의 컴퓨터 환경에서는 메모리 공간이 부족한 경우가 흔히 발생하게 된다.
    - 이 경우 운영체제는 프로그램 수행에 당장 필요한 부분만 메모리에 올려놓고 그렇지 않은 부분은 디스크의 스왑 영역에 내려놓게 된다.
    - 이처럼 디스크에 내려놓는 일을 스왑 아웃(swap out)시킨다고 말하며, 스왑 아웃된 부분이 필요할 때에는 다시 메모리 영역으로 올리게 된다.

## 🍎 캐싱 기법(p.85)
- 캐싱 기법은 상대적으로 느린 저장장치에 있는 내용 중 당장 사용되거나 빈번히 사용될 정보를 빠른 저장장치에 선별적으로 저장함으로써 두 저장장치 사이의 속도를 완충시킨다.
- 예를 들어 프로그램의 코드 중에는 많은 횟수 동안 반복되는 코드와, 한 번 수행되고 끝나는 부분이 있을 수 있다. 이러한 경우 반복되는 코드를 빠른 저장장치에 올려놓으면 적은 저장공간만으로도 전체 시스템의 평균적인 성능을 향상시킬 수 있다.

## 🍎 메모리 보안(p.88)
- 여러 프로그램이 메모리에 동시에 올라가서 실행되기 때문에 하나의 사용자 프로그램이 다른 사용자 프로그램이나 운영체제가 위치한 메모리 영역을 침범할 수 있기 때문에 메모리에도 보안이 필요하다.
- 예를들어 하나의 사용자 프로그램이 C 언어의 포인터 등 메모리 주소 참조 연산을 잘못 사용해 다른 사용자 프로그램의 메모리 영역이나 운영체제 커널이 위치한 영역을 참조하려는 시도를 할 수 있다.
- 이러한 문제를 해결하기 위해 2개의 레지스터를 사용해서 프로그램이 접근하려는 메모리 부분이 합법적인지 체크함으로써 메모리를 보호할 수 있다.
    - 기준 레지스터와 한계 레지스터
    - 기준 레지스터는 프로그램 메모리상의 가장 작은 주소 보관
    - 한계 레지스터는 프로그램 메모리상의 가장 큰 주소 보관
    - 이 프로그램에 접근할 때 현재 접근하려는 위치가 합법적인 범위에 있는지 체크한다.
    - 이 방법은 하나의 프로그램이 메모리의 한 영역에 연속적으로 위치하는 단순화된 메모리 관리 기법을 사용하는 경우에 한전된 설명이다.
- 알아둘 점.
    - 사용자모드인 경우에는 기준 레지스터와 한계 레지스터를 사용해서 메모리를 보호하게 되고, 커널모드에서는 메모리에 무제한으로 접근하는 것이 가능하다.
    - 메모리 접근 명령은 특권명령이 아니지만, 올바르지 않은 접근 시도로부터 메모리를 보호하기 위해서는 기준 레지스터와 한계 레지스터 값을 세팅하는 연산은 특권 명령으로 규정해야 한다.

## 🍎 커널의 주소 공간(p.102)
- 운영체제도 하나의 프로그램이므로 운영체제 커널 역시 코드, 데이터, 스택의 주소 공간 구성을 가지고 있다.
### 📖 커널의 코드 영역
- 커널의 코드 영역에는 CPU, 메모리 자원을 관리하기 위한 부분과 사용자에게 편리한 인터페이스를 제공하기 위한 부분, 이 밖에도 시스템 콜 및 인터럽트 처리를 위한 부분을 포함한다.
### 📖 커널의 데이터 영역
- 각종 자원을 관리하기 위한 자료구조가 저장된다.
- CPU나 메모리와 같은 하드웨어 자원을 관리하기 위한 자료구조뿐 아니라 현재 수행 중인 프로그램을 관리하기 위한 PCB도 가지고 있다.
### 📖 커널의 스택 영역
- 커널의 스택영역은 일반 프로세스의 스택 영역과 마찬가지로 함수 호출시의 복귀 주소를 저장하기 위한 용도로 사용된다.
- 커널의 스택은 사용자 프로세스와 달리 현재 수행 중인 프로세스 마다 별도의 스택을 두어 관리한다.
- 사용자 프로그램에서 커널에 정의된 시스템 콜을 호출하고 시스템 콜 내부에서 다른 함수를 호출하는 경우 그 복귀 주소는 커널 내의 주소가 되어 사용자 프로그램의 스택과는 별도의 저장공간이 필요하기 때문.
- 커널은 일종의 공유 코드로서 모든 사용자 프로그램이 시스템 콜을 통해 커널의 함수를 접근할 수 있으므로, 일관성 유지를 위해 각 프로세스마다 커널 내에 별도의 스택을 두게 되는 것이다.

## 🍎 인터럽트 처리(p.106)
- 원칙적으로는 인터럽트 처리 중에 또 다른 인터럽트가 발생하는 것을 허용하지 않는다.
- 그 이유는 인터럽트 처리 중에 다른 인터럽트를 처리하면 데이터의 일관성이 유지되지 않는 문제가 발생할 수 있기 때문이다.
- 하지만 현재 처리 중인 인터럽트보다 더 높은 우선순위의 인터럽트가 발생한다면 현재 처리 중이던 인터럽트 코드의 수행 지점을 저장하고 우선순위가 높은 인터럽트를 처리하게 된다. 인터럽트 처리가 끝나면 저장된 주소로 복귀해 이전에 수행하던 인터럽트 처리 코드를 마저 수행하게 된다.

## 🍎 I/O 완료 후 보내는 인터럽트의 역할(p.109)
- 입출력을 요구했던 프로세스에게 다시 CPU를 획득할 수 있는 권한을 주는 것이다.
- 즉 blocked에서 ready상태로 바꿔주는것.
- 입출력을 요청했던 프로세스는 입출력 요청이 완료된 후 컨트롤러가 인터럽트를 발생시킨 시점부터 다시 CPU를 얻을 수 있는 자격을 부여받게 된다.


## 🍎 프로세스의 두 가지 실행 상태(p.110)
- 사용자모드에서의 실행 상태
- 커널모드에서의 실행 상태
- 프로세스 A에서 입출력 요구가 있어 시스템 콜을 수행하고 있다해도 여전히 사용자모드에서의 실행 상태라고 이야기 한다. 왜냐하면 비록 운영체제가 입출력 요구 때문에 그 일을 대신해주고 있지만 그 일을 부탁한것은 프로세스 A이기 때문이다.

## 🍎 문맥교환이 일어나는 경우(p.117)
- 타이머 인터럽트가 발생하는 경우
- 실행 상태에 있던 프로세스가 입출력 요청 등으로 봉쇄 상태로 바뀌는 경우
- 이때 준비 상태에 있는 프로세스들 중에서 CPU를 할당받을 프로세스를 선택한 후 실제로 CPU의 제어권을 넘겨받는 과정을 CPU 디스패치라고 한다.
- 간단하게 운영체제를 지났을때 CPU를 같은 프로세스가 가지고 있다면 문맥교환 X
- 다른 프로세스가 CPU를 소유하고 있다면 문맥교환 O

## 🍎 프로세스 제어블록(p.119)
- 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조
    - 프로세스의 상태
    - 프로그램 카운터의 값
    - CPU 레지스터의 값
    - CPU 스케쥴링 정보
    - 메모리 관리 정보
    - 자원 사용 정보
    - 입출력 상태 정보
- 프로세스의 상태는 CPU를 할당해도 되는지 여부를 결정하기 위해 필요.
- 프로그램 카운터값은 다음에 수행할 명령의 위치를 가리키며, CPU 레지스터값은 CPU 연산을 위해 현 시점에 레지스터에 어떤 값을 저장하고 있는지를 나타낸다.
- CPU 스케쥴링 정보와 메모리 관리 정보는 각각 그 프로세스의 CPU 스케쥴링과 메모리 할당을 위해 필요한 정보이다.
- 자원 사용 정보는 사용자에게 자원 사용 요금을 계산해 청구하는 등의 용도로 사용된다.

## 🍎 프로세스를 스케쥴링하기 위한 큐(p.123)
- p.123의 이미지를 참고하면 좋다.
- 운영체제는 준비 상태에 있는 프로세스들을 줄 세우기 위해 준비 큐(ready queue)를 두고 준비 큐의 제일 앞에 줄 서 있는 프로세스에 제일 먼저 CPU를 할당한다.
- 준비 큐에 프로세스를 줄 세우는 방법은 CPU 스케쥴링 방법에 따라 달라진다.
- 이 큐 이외에도 장치 큐(device queue)를 둔다.
- 공유데이터는 매 시점 하나의 프로세스만이 접근 할 수 있다.
    - 데이터의 일관성.
- 이러한 프로세스의 상태 관리는 커널의 주소 영역 중 데이터 영역에서 다양한 큐를 두어 수행한다.
    - 커널의 데이터 영역에 준비 큐(ready), 장치 큐(device), 작업 큐(job)을 두고 프로세스를 관리한다.

## 🍎 스케쥴러(p.127)
- 단기 스케쥴러(CPU를 누구에게 줄까?)
    - 준비 상태의 프로세스 중에서 어떤 프로세스를 다음번에 실행 상태로 만들 것인지 결정한다.
    - 시분할 시스템에서는 타이머 인터럽트가 발생하면 단기 스케쥴러가 호출된다.
    - 밀리 초 단위로 매우 빈번하게 호출되기 때문에 수행속도가 충분히 빨라야한다.
- 중기 스케쥴러(어떤 메모리를 뺏을까?)
    - 메모리에 올라와 있는 프로세스 중 일부를 선정해 이들로부터 메모리를 통째로 빼앗아 그 내용을 디스크의 스왑 영역에 저장해둔다.(swap out)
    - 스왑아웃하는 순위는
        - 봉쇄(blocked) 상태에 있는 프로세스들을 먼저 스왑아웃!
        - 그래도 부족하면 타이머 인터럽트가 발생해 준비 큐로 이동하는 프로세스를 추가적으로 스왑 아웃.
    - 스왑 아웃(swap out)의 의미
        - 외부적인 이유로 프로세스의 수행이 정지된 상태를 나타내는 중지(suspend)상태이다.
        - 메모리를 통째로 빼앗기고 디스크로 스왑 아웃된다.
    - 중지 상태는 중지준비 상태와 중지봉쇄 상태로 나뉘는데 이전에 프로세스가 무슨 상태였는지에 따라 달라진다.
- 장기 스케쥴러(메모리를 누구에게 줄까?)
    - 시작 상태의 프로세스에게 메모리 할당을 승인할지 여부를 장기 스케쥴러가 결정한다.
    - 즉 메모리를 줄지말지 결정하는 스케쥴러
    - 현대의 시분할 시스템에서는 장기 스케쥴러를 두지 않는다.
    - 과거에는 적은 양의 메모리를 많은 프로세스들에게 할당하면 프로세스당 메모리 보유량이 지나치게 적어져 시스템의 효율이 매우 떨어졌기 때문에 장기 스케쥴러가 이를 조절하는 역할을 담당했지만 현재는 메모리도 커졌고 시분할 처리 기법 사용에 따라 프로세스가 시작 상태가 되면 곧바로 프로세스에 메모리를 할당해 준비큐에 넣어준다.
