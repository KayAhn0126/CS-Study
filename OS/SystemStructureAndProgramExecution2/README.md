# System Structure & Program Execution 2
- System Structure & Program Execution 1에서 이어지는 강의

## 🍎 CPU내 프로그램 카운터의 역할
- CPU는 항상 메인 메모리의 Instruction(기계어)을 읽고 실행한다.
- 그럼 CPU는 Instruction이 어디있는지 알고 읽어올까?
- CPU안에 있는 레지스터 중에서 메모리 주소를 가리키고 있는 레지스터가 있는데 이것을 Program Counter Register라고 부른다.
- CPU는 Program Counter Register가 가리키고 있는 위치에서 Instruction을 하나 읽어와서 실행하고 메모리 주소를 가리키고 있던 Program Counter Register는 다음 주소를 가르키게 된다.
    - 교수님이 Instruction 하나가 보통 4 byte 정도 된다고 하셨다.
    - 즉, 다음 실행될 Instruction의 위치는 보통 현재 Program Counter에서 4바이트를 추가한 주소가 된다.
    - **프로그램에서 함수 호출이나 JUMP 같은 상황이 발생 할 수도 있으므로 메모리의 주소가 항상 4씩 늘어나는것은 아니다!**
- CPU의 역할은 메인 메모리에 있는 Instruction을 읽고 실행하는 것이라고 했다.
- **조금 더 자세히 말하자면 CPU는 자신이 가지고 있는 레지스터 중 다음 실행 해야할 메모리 주소를 가리키고 있는 Program Counter를 통해 메모리에 접근하고, 그 안에 있는 Instruction을 실행하는 것이다.**

## 🍎 CPU가 하나의 Instruction을 실행하고 Interrupt Line을 체크한다고 했다.
- Interrupt Line을 체크한 후 프로세스는 어떻게 될까?
- CPU가 Interrupt Line에 와있는 Interrupt를 발견하면 Mode Bit을 0으로 바꾸고 자신의 소유권을 OS로 넘긴다.
- 그럼 OS는 자신이 가지고 있는 인터럽트 벡터에서 Interrupt의 종류가 무엇인지 확인한 후, 인터럽트 당한 시점의 레지스터와 program counter를 save하고 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.
    - 인터럽트 벡터
        - 인터럽트 번호와 처리 루틴을 쌍으로 가지는 딕셔너리라고 생각하면 됨
    - 인터럽트 처리 루틴
        - 실제로 인터럽트를 처리하는 커널 함수

## 🍎 Mode Bit에 따라 실행할 수 있는 Instruction의 범위가 다르다.
- Mode Bit이 0일때, 즉, OS가 CPU 소유권을 가지고 있을 때는 모든 Instruction 수행 가능
- Mode Bit이 1일때, 즉, 사용자 프로그램이 CPU 소유권을 가지고 있을 때는 제한된 Instruction 수행 가능

## 🍎 동기식 입출력과 비동기식 입출력
- 동기식 입출력 (synchronous I/O)
    - I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감
    - 구현 방법 1 (비효율적)
        - I/O가 끝날때까지 CPU를 낭비시킴
        - 매 시점 하나의 I/O만 일어날 수 있음
    - 구현 방법 2 (효율적)
        - 사용자 프로그램 X가 있다고 가정해보자
        - Queue처럼 I/O 처리를 기다리는 줄에 사용자 프로그램 X를 넣는다.
        - I/O 처리를 기다리는 Queue에는 CPU 소유권을 주지 않는다.
- 비동기식 입출력(asynchronous I/O)
    - I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감
- **두 경우 모두 I/O의 완료는 인터럽트로 알려줌**

## 🍎 DMA Controller 심화 설명
- 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용
- 원래는 Main Memory에 접근할 수 있는것은 CPU뿐이였는데, CPU의 역할을 분담하기 위해 DMA Controller를 만들고 Main Memory에도 접근 가능하도록 만들었다.
- 만약 I/O Device의 Device Controller가 입력이 끝났다고 Interrupt을 보내면 DMA Controller는 중간에서 그 Interrupt를 가로채 해당 Device Controller에게 device의 local buffer 속 내용을 main memory에 block 단위로 직접 전송하라고 명령한다.
- CPU의 중재 없이 일을 마치고 마지막에 CPU에게 일처리가 끝났다고 Interrupt를 걸어준다.

## 🍎 서로 다른 입출력 명령어
![](https://i.imgur.com/AyT2MAo.png)
- 왼쪽의 그림이 일반적인 형태이다.
    - 메모리에 접근하는 instruction 따로, Device에 접근하는 special instruction 따로 수행하도록 만든 형태.
- 오른쪽의 그림은 Memory Mapped I/O의 예시이다.
    - 즉, 각각의 Device에 메모리를 맵핑시켜 메모리에 접근하는 instruction으로도 접근이 가능하게 만든것

## 🍎 저장장치 계층 구조
![](https://i.imgur.com/rJhbAIL.png)
- 초록 -> 주기억(휘발성), 빨강 -> 보조기억(비휘발성)
- 순서
    - 이미지엔 없지만 맨 위에는 CPU
    - ------------ (아래 3개는 바이트 단위로 이뤄져 있기 때문에 CPU가 직접 접근 가능!)
    - CPU안에 Register
    - CPU안에 Cache Memory
    - DRAM으로 구성된 Main Memory
    - ------------ (아래 3개는 섹터 단위로 이뤄져 있기 때문에 CPU가 실행 불가!)
    - Magnetic Disk(HDD)
    - Optical Disk
    - Magnetic Tape
- 위로 올라 갈수록 빠르고 공간대비 가격이 높아진다.
- 즉, 위로 올라갈수록 빠르지만 저장공간이 별로 없다.
- CPU는 1 클락 당 하나의 Instruction을 처리한다.
- DRAM으로 구성된 Main Memory에 접근하려면 수십 사이클에서 100 사이클까지 걸리는데 자주 사용하는것을 더 가까이 두면 굳이 다시 Main Memory에 접근하지 않아도 되기 때문에 CPU의 성능 향상을 위해 캐시메모리를 두고, 캐시 메모리에는 자주 사용하는 Instruction을 넣는다.

## 🍎 프로그램의 실행(메모리 load)
![](https://i.imgur.com/s33aSb3.png)
- 보통 프로그램이라하면 실행 파일 형태로 하드디스크에 저장 되어있다.
- 실행 파일을 실행 시키면 메모리로 올라가서 프로세스가 된다.
- 더 정확하게는 물리적인 메모리에 바로 올라가는것이 아니라 중간에 한 단계를 더 거치게 되는데, 그것은 해당 프로그램만의 독자적인 메모리 주소 공간이 형성되는 가상 메모리(Virtual memory)단계 이다.
    - 독자적인 메모리 주소 공간이라 0번지부터 시작한다.
    - 만약 실행파일 A를 실행시키면 실행파일A의 독자적인 메모리 주소 공간은 0번지 부터 시작하고,
    - 이후 실행파일 B를 실행시키면 실행파일A의 메모리 주소 공간과 상관 없이 실행파일B의 독자적인 메모리 주소 공간도 마찬가지로 0번지 부터 시작한다.
    - 이 메모리 주소 공간은 Code, Data, Stack이라는 공간으로 구성된다.
        - Code 공간에는 CPU에서 실행할 기계어 코드를 담고있다.
        - Data 전역변수 처럼 해당 프로그램이 필요한 자료구조를 담고있다.
        - 프로그램 실행시 함수 호출을 위해 넣고 뺄 수 있는 공간이다.
    - **알아두기** -> 위의 이미지에서는 code영역이 끝나면 data영역이 시작되는것처럼 보이지만, 실제로는 순차적으로 연결되어있지 않고 code영역은 물리적 메모리에, 나머지 당장 사용되지 않는 정보들은 디스크의 Swap Area에 있다고 생각하면 된다.
- 이제 프로그램을 사용하기 위해서 물리적 메모리에 올려야한다!
    - 참고: 이미지의 중간 아래에 있는 Kernel Address space는 컴퓨터를 켜면 물리적 메모리에 올라가고 컴퓨터 종료 까지 항상 올라가있는다.
    - 하지만 사용자 프로그램들은 실행이 되면 메모리 주소 공간(가상)이 생겼다가 프로그램을 종료 시키면 사라진다.
- **메모리 낭비 때문에 사용자 프로그램을 실행 시켰을때 생긴 메모리 주소 공간 전체가 물리적 메모리에 올라가는것은 아니다!**
    - 보통 가상 메모리의 code 영역만 물리적 메모리에 올려 놓는다.
    - 그리고 당장 필요하지 않은 정보들은 디스크의 Swap Area에 내려 놓는다.
- 위의 이미지에서 두개의 디스크가 있다.
    - 좌측 하단 디스크는 컴퓨터가 켜져있을때만 잠시 정보를 담아두는 휘발성이고
    - 우측 중앙 디스크는 컴퓨터가 꺼져도 정보를 유지하는 비 휘발성이다.

## 🍎 커널 주소 공간의 내용
- 위의 프로그램의 실행에 있는 이미지를 보면 운영체제의 커널도 code, data, stack으로 이루어져 있다.
- 즉, 운영체제의 커널도 결국 하나의 프로그램 이라는것!
![](https://i.imgur.com/VbRxV8s.png)

### 📖 코드 영역
- OS는 Interrupt가 들어오면 CPU를 얻는다. 그로인해 OS의 커널에는 여러 인터럽트를 처리하기 위한 벡터 존재.

### 📖 데이터 영역
- 직접적으로 CPU, Memory, Disk를 관리
- 프로세스 관리
    - Process Control Block
    - 프로그램의 실행을 설명하는 이미지에서 물리적 메모리에서 핑크색과 파란색을 커널에서 PCB로 관리 하는 것 이다.
    - 즉, 실제 프로그램이 돌아가면 그 프로그램을 관리하기 위한 영역이 커널에 만들어 지는데 이것을 PCB라고 부른다.

### 📖 스택 영역
- 사용자 프로그램마다 커널 스택을 따로 두고 있다!
- 즉, 현재 어떤 사용자 프로그램이 커널의 함수를 쓰고있는지 스택으로 표현

## 🍎 사용자 프로그램이 사용하는 함수
![](https://i.imgur.com/XUiQpaT.png)
- 사용자 정의 함수
    - 자신의 프로그램에서 정의한 함수
- 라이브러리 함수
    - 자신의 프로그램에서 정의하지 않고 갖다 쓴 함수
- 커널 함수
    - 운영체제 프로그램의 함수
    - 커널 함수의 호출 = 시스템 콜
- 이미지 해석
    - 사용자 정의 함수와 라이브러리 함수를 사용한 코드를 컴파일 해서 실행 파일을 만들게 되면 내 실행 파일안에는 사용자 정의 함수 + 라이브러리 함수가 들어있다.
    - 하지만 커널 함수는 내 프로그램 안에 작성하고 컴파일을 해도 커널 메모리 주소 공간의 코드 영역에 들어있다.
    - 예) Scanf, Cin
- 사용자 프로그램에서 사용 할 수 있는 함수들은 그 안에서 자유롭게 사용 가능하지만 사용자 프로그램에서 I/O 요청시 커널 함수에 직접 접근을 할 수 없으므로 운영체제에게 부탁하는것!
![](https://i.imgur.com/DTEGEL7.png)
