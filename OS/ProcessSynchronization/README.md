# Process Synchronization

## 🍎 프로세스 동기화
- 프로세스 동기화의 중요 키워드는 "lock"이다.
- 어떤 프로세스가 특정 데이터에 접근해서 수행 중일때 다른 프로세스가 헤당 데이터에 대해서 접근할 수 없도록 만드는것이 데이터에 대해 일관성을 보장하기 때문이다.
- 일관성을 보장하기 위해서는 프로세스 동기화가 필요하고 동기화란 프로세스들 사이의 수행 시기를 맞추는것을 의미한다.
- 프로세스들 사이의 수행 시기를 맞추는 것은 크게 아래 두가지를 의미한다.
    - 실행 순서 제어: 프로세스를 올바른 순서대로 실행하기
    - **상호 배제: 동시에 접근해서 안되는 자원에 하나의 프로세스만 접근하게 하기**
- **상호 배제의 개념은 실행 순서 제어를 포함하고 있다.**

## 🍎 Race Condition
- Race Condition이 생길 수 있는 예시를 보자
### 📖 Interrupt handler vs kernel
![](https://i.imgur.com/zwq3bus.png)
- 현재 커널에서 Count라는 변수의 값을 1 증가 시키는 작업이 실행되고 있다.
- 보통 고급언어에서 변수의 값을 1 증가 시키는 문장이 CPU 내부에서는 이미지의 1,2,3번 처럼 여러개의 instruction을 통해서 실행이 된다.
    - 1. Load
    - 2. Inc
    - 3. Store
- CPU에서는 "Count++"을 어떻게 실행하냐면,
    - 먼저 memory에 있는 변수 Count의 값을 CPU안에 있는 레지스터로 불러들인다.(load)
    - 그 레지스터 값을 1 증가 시키고 (Inc)
    - 이후 가져왔던 변수 Count에 증가 시킨 값을 저장한다.
- 하지만 만약 CPU가 Count 변수의 값을 레지스터로 읽어들인 상태(Load)에서 이미지의 Interrupt handler가 실행이 된다면 온전히 현재 일을 끝내지 못한 상태에서 Count-- 작업을 실행하게 된다.
- Count-- 작업도 아래와 같은 instruction으로 이루어져있다.
    - 1. Load
    - 2. Dec
    - 3. Store
- 전체적인 그림에서 보자면 아래와 같은 프로세스로 진행이 되어서 결과적으로는 Count-- 작업은 실행이 안된것과 마찬가지인 결과가 나온다.
    - Count++ 작업으로 인한 Count 값을 레지스터A에 Load
    - 이때 Count-- 작업으로 인한 Count값을 또 다른 레지스터 B에 Load
    - 레지스터 B에서 값을 1만큼 빼기
    - 레지스터B에 있는 값을 Count 변수에 저장
    - 아까 실행중이던 Count++ 작업으로 돌아와서 레지스터A에 있는 값 1만큼 더하기
    - 레지스터A에 있는 값을 Count 변수에 저장
    - 끝
- 이 경우, 결과적으로는 Count-- 한것은 반영이 안된다.
- 결국에는 실행 순서를 정해주면 된다.
- 어떠한 프로세스가 공유 자원에 대해서 일을하고 있을때 다른 프로세스가 해당 공유 자원에 접근하지 못하게 막으면된다.
- 하지만 무조건 막는다고 좋은것은 아니다!
- **효율적으로 막는것이 중요하다!**

## 🍎 The Critical Section Problem
- 공유자원은 전역변수가 될 수도 있고, 파일이 될 수도 있고, 입출력장치, 보조기억장치가 될 수도 있다.
- n개의 프로세스가 공유 데이터를 동시에 사용하기 원하는 경우
- 각 프로세스의 code segment에는 공유 데이터를 접근하는 코드인 critical section이 존재
- problem
    - 하나의 프로세스가 Critical section에 있을 때 다른 모든 프로세스는 critical section에 들어갈 수 없어야 한다.

![](https://i.imgur.com/NmaRDM2.png)
- 이미지에서 빨간 네모 박스가 critical section이다.

## 🍎 결국 임계구역에 동시에 접근하지 못하도록 관리하는것이 포인트
- 운영체제는 임계 구역 문제를 아래 세가지 원칙하에 해결한다.
- 상호 배제 (mutual exclusion)
    - 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없다.
- 진행 (progress)
    - 임계 구역에 어떤 프로세스도 진입하지 않았다면 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야 한다.
    - 당연한 말처럼 들리지만 이 조건이 만족이 안될 수 있다. 상호 배제에서 둘이 동시에 들어가려는것을 막고자 하다보니까 둘 다 못들어가는 상황이 생긴다.
- 유한 대기 (Bounded Waiting)
    - 프로세스가 임계 구역에 들어가려고 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 임계구역에 들어가는 횟수에 한계가 있어야 한다.
    - Starvation를 방지하기 위함이다.
    - 예) 3개의 프로세스가 임계 영역에 접근하려하는데 2개는 서로 번갈아 가면서 들어갔다 나오고 하는데 나머지 하나가 들어가지 못하는 상황

## 🍎 프로세스 동기화 기법
- 안전하게 프로세스들이 공유 자원을 사용하는 방법을 알아보자!
### 📖뮤텍스 락
- 상호 배제를 위한 동기화 도구
- 탈의실 예제를 생각하자.
- 만약 밖에서 탈의실에 사람이 있는지 없는지 알 수 없는 상황이라면 탈의실이 이용중인지 어떻게 알 수 있을까?
- 일단 탈의실을 열어보고 안에서 잠겨져 있다면 탈의실에 사람이 있다고 판단한다. 또는 잠기지 않았다면 탈의실을 이용하면 된다.
- 즉, 임계 구역에 진입하는 프로세스는 '내가 지금 임계 구역에 있음'을 알리기 위해 뮤텍스 락을 이용해 자물쇠를 걸어둘 수 있고, 다른 프로세스는 임계 구역이 잠겨 있다면 기다리고, 잠겨 있지 않다면 임계 구역에 진입할 수 있다.
- 뮤텍스 락의 매우 단순한 형태는 하나의 전역 변수와 두개의 함수로 구현할 수 있다!
    - 자물쇠 역할 : 프로세스들이 공유하는 전역 변수 lock
    - 임계 구역을 잠그는 역할 : acquire 함수
    - 임계 구역의 잠금을 해제하는 역할 : release 함수
- acquire 함수는 **프로세스가 임계 구역에 진입하기 전에 호출하는 함수.**
- 만약 임계 구역이 잠겨 있다면 임계 구역이 열릴 때까지 임계 구역을 반복적으로 확인하고, 임계 구역이 열려있다면 임계 구역을 잠그는 함수.
- release 함수는 임계 구역에서의 작업이 끝나고 호출하는 함수. 현재 잠긴 임계 구역을 열어주는 함수
- 코드로 보면 아래와 같다
```bash
acquire() {
    while(lock == true) { # 잠겨있다면,
        continue; 
    } 
    lock = true # 잠기지 않았으면 잠그고 임계 구역 진입
}
    
release() {
    lock = false # 임계 구역에서 나올때는 lock 해제
}
```
- 실제로 사용되는 코드
```bash
# 자물쇠 잠겨 있는지 확인, 잠겨있지 않다면 잠그고 들어가기
acquire();
# 임계 구역에서의 작업 진행
/임계 구역/ 
# 자물쇠 해제하기
release();
```
- acquire() 함수에서 임계 구역이 잠겨있는지 계속 확인하는 무한 루프가 있는데, 마치 탈의실 문이 잠겨 있는지 쉴 새 없이 반복하며 확인해보는 상황과 같다. 이런 대기 방식을 바쁜 대기(busy wait)이라고 한다.

### 📖 세마포어
- 뮤텍스 락과 비슷하지만, 더 일반화된 방식의 동기화 도구.
- 뮤텍스 락은 하나의 공유 자원에 접근하는 프로세스를 상정한 방식
    - 즉, 탈의실이 하나 있는 경우를 가정하고 만든 동기화 도구
    - 하지만 탈의실이 여러 개 있는 상황처럼 공유 자원이 여러 개 있을 경우 (각 공유 자원에는 하나의 프로세스만 진입이 가능할지라도) 여러 개의 프로세스가 각각 공유 자원에 접근이 가능해야 한다.
- 이진 세마포어, 카운팅 세마포어가 있다.
    - 이진 세마포어는 뮤텍스 락과 비슷한 개념
- 구현
    - 임계 구역에 진입할 수 있는 프로세스의 개수(사용 가능한 공유 자원의 개수)를 나타내는 **전역 변수 S**
    - 임계 구역에 들어가도 좋은지, 기다려야 할지를 알려주는 **wait 함수**
    - 임계 구역 앞에서 기다리는 프로세스에 '이제 가도 좋다'고 신호를 주는 **signal 함수**
- 뮤텍스 락과 비슷하지만 조금 다르다!
- 전역 변수 S는 임계 구역에 진입할 수 있는 프로세스의 개수, 혹은 사용 가능한 공유 자원의 개수라고 했다. 이를 토대로 생각해 봤을때 wait 함수는 아래와 같이 만들 수 있다.
- wait() 함수
```bash
wait() {
    while(S <= 0) { # 임계 구역에 진입할 수 있는 프로세스 개수가 0 이하라면
        continue; # 반복문의 처음으로
    }
    S--; # 임계 구역에 진입 할 수 있다면, S를 1 감소 시키고 임계 구역 진입.
}
```
- signal() 함수
```bash
signal() {
    S++; # 임계 구역에서 작업을 마친 뒤 S를 1 증가 시킨다.
}
```
- 여기서 문제가 있다. 이는 앞서 설명한 뮤텍스 락에도 해당되는 문제인데, 사용할 수 있는 공유 자원이 없는 경우 프로세스는 무작정 무한히 반복하며 S를 확인한다. 이는 마치 탈의실 문이 잠겨 있는지 아닌지 계속 반복해서 확인하는 것과 같다. 이렇게 바쁜 대기를 반복하며 확인할 시간에 CPU는 더 생산성 있는 작업을 할 수 있을 텐데, CPU 주기를 낭비한다는 점에서 손해다.
- 그래서 **실제로 세마포어는 더 좋은 방법을 사용한다. 아주 중요!**
- wait 함수는 만일 사용할 수 있는 자원이 없을 경우 해당 프로세스 상태를 대기 상태로 만들고, 그 프로세스의 PCB를 세마포어를 위한 대기 큐에 집어 넣는다. 그리고 다른 프로세스가 임계 구역에서의 작업이 끝나고 signal 함수를 호출하면 signal 함수는 대기중인 프로세스를 대기큐에서 제거하고, 프로세스 상태를 '준비 상태'로 변경한 뒤 준비 큐로 옮겨준다.
- 아래의 예시 코드를 보자!
- 실제 세마포어의 wait() 함수
```bash
wait() {
    S--;
    if (S < 0) {
        add this process to Queue # 해당 프로세스를 대기 큐에 삽입한다.
        sleep(); # 대기 상태로 접어든다.
    }
}
```
- signal() 함수
```bash
signal() {
    S++;
    if (S <= 0) {
        remove a PCB object from Queue # 대기 큐에 있는 프로세스를 큐에서 빼낸다.
        wakeup(PCB-object) # 프로세스를 준비 상태로 만든다.
    }
}
```
- 지금까지 세마포어를 이용한 상호 배제를 위한 동기화 기법에 대해 공부했다.
- 이제 **세마포어를 이용한 순서 제어**에 대해서 알아보자.
- 세마포어를 이용하면 동시에 실행되는 프로세스의 실행 순서를 마음대로 제어할 수 있다.
- 세마포어의 변수 S를 0으로 두고 먼저 실행할 프로세스 뒤에 signal 함수, 다음에 실행할 프로세스 앞에 wait 함수를 붙이면 된다.
![](https://i.imgur.com/inn8yMK.jpg)

### 📖 모니터
- 세마포어는 그 자체로 충분히 훌륭한 프로세스 동기화 도구이지만, 사용하기가 조금 불편한 면이 있다.
- 매번 임계 구역에 앞뒤로 일일이 wait과 signal 함수를 명시하는 것은 번거로운 일이기 때문이다.
- 이에, 최근 등장한 동기화 도구가 모니터이다.
- 세마포어는 어셈블리어에 적합한 동기화 도구였다면 모니터는 고급언어인 JAVA에 적합한 동기화 도구이다.
- 모니터는 개발자가 다루기에 편한 동기화 도구
    - 실행 순서 제어를 위한 동기화
    - 상호 배제를 위한 동기화
    - 두 가지 방법을 모두 제공해주는 동기화 방식
    - 두 가지 방법 모두 모니터에는 한 번에 하나의 프로세스만 공유 자원 이용이 가능하다!
- **상호 배제를 위한 동기화**
![](https://i.imgur.com/JrMKGlt.png)
- 큐에 있는 프로세스를 공유 자원 연산(인터페이스)에 넣는다.
- **실행 순서 제어를 위한 동기화**
    - 조건 변수를 이용 -> **Wait()와 Signal()함수를 호출할 수 있는 특별한 변수**
    - 프로세스나 스레드의 실행 순서를 제어하기 위해 사용하는 특별한 변수
![](https://i.imgur.com/toRvCeI.png)
- 모니터 안에 보면 각각의 조건 변수마다 큐가 만들어져 있다.
    - 조건 변수.wait(): 대기 상태로 변경, 조건 변수에 대한 큐에 삽입
    - 조건 변수.signal(): wait()으로 대기 상태로 접어든 조건 변수를 실행 상태로 변경
- 예) 프로세스 A, B 둘다 X라는 공유자원을 사용해야한다고 가정해보자.
- 이때, B프로세스가 A프로세스보다 먼저 실행해야 하는데 A프로세스가 큐에서 먼저 나오게 되면, 조건 변수 X가 A프로세스에 대해 wait()함수를 호출한다. 그럼 A프로세스틑 조건변수 X의 큐에 들어가서 B프로세스가 모니터에서 공유 자원에 대해 연산을 하고 나갈때까지 기다리고 있다가 나가게 되면 그때 조건 변수 X의 큐에서 나와 모니터의 인터페이스 큐에 들어간다. 

## 🍎 공부 내용 출처
- [반효경 교수님](https://core.ewha.ac.kr/publicview/C0101020140404144354492628?vmode=f)
- [혼자공부하는 운영체제 책](https://www.youtube.com/watch?v=4u13f9Umq7Y&list=PLVsNizTWUw7FCS83JhC1vflK8OcLRG0Hl&index=36)
