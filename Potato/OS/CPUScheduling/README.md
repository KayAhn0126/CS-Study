# CPU Scheduling
- 현대의 운영체제가 사용하는 시분할 처리 방식을 더 효율적으로 사용하기 위함이다.
## 🍎 스케줄링의 목표
- 리소스 사용률
    - 보통은 CPU 사용률을 높이는 것을 목표
- 오버헤드 최소화
    - 스케줄링을 하기 위한 계산이 너무 복잡하거나 컨텍스트 스위칭을 자주하는것을 방지
- 공평성
    - 모든 프로세스에게 CPU를 공평하게 할당
    - 하지만 시스템에 따라 달라진다.
- 처리량
    - 같은 시간내에 더 많은 처리 할 수 있는 방법을 목표로 한다.
- 대기시간
    - 작업을 요청하고 실제 작업이 이루어지기 전까지 대기하는 시간이 짧은 것을 목표로 한다.

## 🍎 CPU Scheduling 개요
- 프로그램을 실행시키면 메모리에 프로세스가 생성되고 각 프로세스에는 1개 이상의 스레드가 있다.
- 프로세스들은 CPU를 차지하기 위해 운영체제의 명령을 기다린다.
- 운영체제는 모든 프로세스에게 CPU를 할당/해제 하는데 이를 'CPU 스케줄링' 이라고 한다.
- CPU 스케줄링에서 스케줄러(운영체제)가 고려해야 할 사항은 두가지가 있다.
    - 1. 어떤 프로세스에게 CPU 리소스를 줘야하는가?
        - 메모리에는 수 많은 프로세스들이 있는데, 한 프로세스에게만 계속 할당 한다면 다른 프로세스들이 진행을 못한다.
    - 2. CPU를 할당 받은 프로세스가 얼마의 시간동안 CPU를 사용 해야하는가?
        - 오늘날의 운영체제는 시분할 방식으로 여러 프로세스들에게 짧은 시간동안 돌아가면서 CPU를 할당한다.

## 🍎 다중 큐
- 프로세스 정보를 담고있는 PCB는 준비상태의 다중큐에 들어가서 실행되기를 기다리고 있고 CPU 스케줄러에 의해 실행상태로 전환된다.
- 이 때 CPU 스케줄러는 준비상태의 다중큐를 참조해서 어떤 프로세스를 실행 시킬지 결정한다.

## 🍎 스케줄링 알고리즘
- 다중큐에서 실행되기를 기다리고 있는 PCB들을 어떤 기준으로 실행 시킬지 결정하는 것을 스케줄링 알고리즘이라 한다.
- **스케쥴링의 성능은 "평균 대기 시간"으로 평가 한다.**

### 📖 FIFO (First In First Out)
- 스케줄링 큐에 들어온 순서대로 CPU를 할당 받는 방식
    - 작업 순서에 따라 평균 대기 시간이 크게 달라질 수 있음
- 일괄 처리 방식에서 쓰인다. 시분할 처리 시스템에서는 쓰이지 않음.

### 📖 SJF (Shortest Job First)
- 스케줄링 큐에 있는 PCB들 중 수행시간(burst time)이 짧은것들을 먼저 수행한다.
- 이론적으로는 FIFO보다 빠르지만, 단점으로는 중간에 계속 수행시간이 짧은 프로세스가 들어오면 수행시간이 긴 프로세스는 아예 실행되지 않을 수 있다.
- 프로세스의 종료 시간을 예측하기 힘들다.
    - "수행시간이 긴 프로세스는 언제 끝나는지 알 수 있을까?"를 생각 해보면 된다.

### 📖 RR (Round Robin)
- 만약 어떤 큐를 처리할 때, RR 알고리즘과 FIFO 알고리즘의 평균 대기 시간이 비슷하다면 RR 알고리즘이 더 비효율 적이라고 볼 수 있다.
    - RR 알고리즘은 컨텍스트 스위칭을 자주하기 때문에 컨텍스트 스위칭 시간이 더 추가되고, 오버헤드도 더 크다.
- RR 알고리즘의 성능은 타임 슬라이스(하나의 프로세스가 CPU를 점유 할 수 있는 시간)의 값에 따라 크게 달라진다.
    - 타임 슬라이스의 값이 크면 FIFO와 비슷해진다.
    - 반대로 타임 슬라이스의 값이 너무 작으면 컨텍스트 스위칭을 하는 비용이 많이든다. -> 오버헤드가 크다.

### 📖 MLFQ (Multi Level Feedback Queue)
- 현대의 운영체제에서 사용하는 방식이다.
- 기본적으로 CPU 사용률과 I/O 사용률이 좋게 나오는 작은 크기의 타임 슬라이스를 선택한다.
    - CPU Bound process(CPU 작업이 메인인 프로세스)에게는 긴 타임 슬라이스를 주고, I/O Bound process(I/O 작업이 메인인 프로세스)에게는 짧은 타임 슬라이스를 준다.
- 운영체제는 해당 프로세스가 CPU Bound process인지 I/O Bound process인지 어떻게 알 수 있을까?
    - CPU를 사용하던 프로세스가 운영체제로 부터 CPU의 점유를 강제로 뺏기는 작업은 CPU를 오래 사용하고 있었으니 CPU Bound process라고 생각하고, 그렇지 않고 수행 되자마자 바로 반납하는 작업을 I/O 작업이라 생각한다.
- 멀티 레벨 피드백 큐는 아래와 같이 생겼다.
    - 우선순위 1  [                          ]  (타입 슬라이스 1초)
    - 우선순위 2  [                          ]  (타입 슬라이스 3초)
    - 우선순위 3  [                          ]  (타입 슬라이스 10초)
    - 우선순위 4  [                          ]  (타입 슬라이스 30초)
    - ...
    - ...
    - 우선순위 N  [                          ]  (타입 슬라이스 무한초)
- 우선순위가 높으면 타임 슬라이스가 작고, 낮을수록 타임 슬라이스가 크다.
- 만약 특정 프로세스1이 우선순위 1 큐에 있다가 타임 슬라이스 크기를 오버해서 강제로 CPU를 뺏긴다면 우선순위 2 큐에 들어간다. 우선순위 2 큐에 들어간 프로세스1에는 이제 더 긴 타임 슬라이스를 할당 받게 되고, 여기서도 부족하면 우선순위 3 큐에 들어가 더 긴 타임 슬라이스를 받는다.
- 마지막 우선순위 큐 N에 들어가면 FIFO 처럼 연속적으로 작업을 수행한다.
