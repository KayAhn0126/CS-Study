# Process and Thread

## 🍎 프로그램과 프로세스
### 📖 프로그램
- 프로그램은 하드 디스크등과 같은 저장 장치에 저장된 명령문의 집합체.
### 📖 프로세스
- 프로세스는 프로그램(저장장치에 저장된 명령문의 집합체)를 메인 메모리에 올려 CPU가 명령문을 수행하는것.
    - 프로세스가 생성되면 프로세스 상태에서의 "생성" 단계가 되는데, 이때 PCB를 생성한다.
- 프로세스의 구조
    - 코드
        - CPU가 실행 해야할 명령어들이 저장되어 있다.
    - 데이터
        - 전역변수와 정적(Static)변수가 저장되어 있다.
    - 힙
        - 프로그래머가 런타임시 할당할 수 있는 메모리 공간
    - 스택
        - 지역변수들 및 함수 호출시 매개변수와 돌아갈 주소가 저장되어있다.
### 📖 컴파일 과정
- C언어의 파일 (xxx.c)을..
    - 전처리기를 거쳐 필요한 파일을 불러온다. -> (xxx.i)
    - xxx.i 파일을 컴파일러가 컴파일 해준다. -> (xxx.s)
        - 컴파일을 마치면 고수준인 C언어를 저수준인 어셈블리어로 바꿔준다.
        - 어셈블리어는 명령어가 기계어랑 일대일 매칭이 되기 때문에 기계어와 가장 가까운 언어다. 
    - 이제 어셈블러가 xxx.s 파일을 기계어로 바꿔준다. -> (xxx.o)
        - 이 파일은 0과 1로 이루어진 기계어로 구성된다.
        - 오브젝트 파일이라고 한다.
    - 마지막으로 링커가 xxx.o 파일을 여러 라이브러리나 다른 소스코드와 함께 링킹한다.
        - 링킹 작업 이후에는 우리가 아는 exe파일이된다.
- 만들어진 exe 파일을 실행시키면 exe 파일이 메모리에 올라가게 되고, 올라간 프로그램은 프로세스라는 새로운 이름으로 불리게 된다.

### 📖 CPU가 일하는 방식
```cpp
int num1 = 5;
int num2 = 7;
int result = num1 + num2;
```
- 위에 코드를 기반으로 CPU가 일하는 방식 설명
- CPU는 0과 1만을 읽어들이는데 여기서는 쉽게 어셈블리어로 표현했다.
- 메모리에 올라와 있는 프로세스의 코드 영역의 명령어들을 제어장치가 읽고 저장해야 하는 값들을 제어장치가 레지스터로 가져온다. 이후 연산해야하는 명령어가 있다면 제어장치가 ALU를 통해 레지스터에 있는 버퍼에서 값을 가져와 연산 후 다시 레지스터의 특정 버퍼에 값을 덮어 씌운다.

## 🍎 멀티프로그래밍과 멀티프로세싱
### 📖 유니 프로그래밍 / 멀티 프로그래밍 / 멀티 프로세싱
- 유니 프로그래밍
    - 메모리에 오직 하나의 프로세스가 올라온것
    - 즉, 메모리에 프로세스 1개
- 멀티 프로그래밍
    - 메모리에 여러개의 프로세스가 올라온 것
- 멀티 프로세싱
    - 유니, 멀티 프로그래밍을 메모리의 관점으로 정의 했다면, 멀티 프로세싱은 CPU 관점으로 정의한것이다.
    - CPU가 여러개의 프로세스를 처리하는것을 말한다.

### 📖 스와핑(Swapping)
- 이전에는 메모리에 오직 하나의 프로그램을 올릴 수 있어서 유니 프로그래밍 + 멀티 프로세싱으로 작업했다.
- 이때,CPU가 메모리에 있는 프로세스를 진행한 후 저장장치에 프로세스를 저장해두고 저장장치에 있던 메모리에 올리는 작업을 스와핑이라고 한다.

## 🍎 PCB
### 📖 PCB의 구조
- 프로세스가 만들어지면 운영체제는 해당 프로세스의 정보를 가지고 있는 PCB를 만들고 저장한다.
- PCB는 연결 리스트라는 자료구조로 저장된다.
- PCB는 아래와 같은 구조로 되어있다.
    - 포인터 - 프로세스의 한 상태에서 다른 상태로 전환될 때 사용
    - 프로세스 상태 - 현재 프로세스의 5가지 상태 (생성, 준비, 실행, 대기, 완료)를 나타낸다.
    - 프로세스 ID - PID라고 불리며(프로세스 식별자이다)
    - 프로그램 카운터 - 다음 실행될 명령어의 주소를 가지고 있다.
    - 레지스터 정보 - PC와 같이 다시 프로세스를 실행할 때 필요한 정보 (레지스터 값 들을 가지고 있음)
    - 메모리 관련 정보 - 메모리 침범을 막기 위한 경계 레지스터 값 등이 저장된다.
    - CPU 스케쥴링 정보 - CPU 스케쥴링에 필요한 우선순위, 최종 실행 시간, CPU 점유시간들이 저장된다.

## 🍎 프로세스 상태
- 프로세스의 상태
- 프로세스는 시분할 처리를 위한 다섯가지 상태를 가지고 있다.
    - 생성 / PCB를 생성하고 메모리에 프로그램 적재를 요청한 상태. 메모리에 프로그램 적재를 승인 받으면 준비상태로 넘어간다.
    - 준비 / CPU를 사용하기 위해 기다리고 있는 상태.
        - 대부분의 프로세스는 이 "준비 상태"에 있다.
        - 준비 상태에 있는 프로세스는 CPU 스케쥴러에 의해 CPU가 할당된다.
    - 실행 / 준비상태에 있는 프로세스가 CPU 스케쥴러에 의해 CPU를 할당 받아 실행되는 상태
    - 대기 / 특정 프로세스가 입출력 요청을 하면 입출력이 완료 될때까지 대기 상태로 전환하고 다른 프로세스에게 CPU를 할당한다.
    - 완료 / 프로세스가 종료된 상태 / 프로세스가 사용했던 데이터를 메모리에서 제거하고 PCB도 제거한다.

## 🍎 컨텍스트 스위칭
- CPU가 다른 프로세스를 실행하기 위해 현재 프로세스의 상태를 저장하고 다른 프로세스의 상태값으로 교체하는 작업.
- 컨텍스트 스위칭이 일어날때 PCB의 내용이 변경된다.
- 스위칭이 일어나면, 프로세스 상태, 프로그램 카운터, 레지스터 정보, 메모리 관련 정보를 변경한다.
- System call이나 Interrupt 발생시 반드시 context switch가 일어나는것은 아니다!
- 만약 사용자 프로세스 A에서 timer interrupt 또는 I/O 요청 System call이 일어나서 사용자 프로세스 A가 block 상태가 되어 다른 사용자 프로세스로 CPU 소유권을 넘기는 것은 Context Switch이다.
- 하지만 사용자 프로세스 A에서 interrupt 또는 System call이 발생하고 다시 사용자 프로세스 A로 CPU의 소유권을 넘기면 문맥 교환이 없다. 단지 실행모드만 사용자 모드에서 커널 모드로 바뀌었다가 다시 사용자 모드로 전환된것 뿐이다.
    - Timer interrupt와 I/O 요청 System call을 제외한 interrupt 또는 System call.
- 간단하게 이야기 하면 커널모드에 갔다가 다른 프로세스에게 CPU 소유권을 넘기면 문맥교환이 일어난 것!
- 후자처럼 문맥교환이 일어나지 않더라도 항상 커널 모드로 진입할 때 PCB에 일부 정보를 save해야한다.
- 하지만 전자처럼 문맥을 교환하는 경우 그 부담(오버헤드)가 훨씬 크고, 이전 프로세스가 사용하던 cache memory도 지워줘야 한다.

## 🍎 프로세스 생성
- 모든 프로세스의 부모가 되는 init process 생성
    - 컴퓨터를 부팅하면 OS가 태초의 프로세스 init process를 생성하고 이것의 PCB를 생성한다.
- 일반 프로세스의 생성 방법
    - 맨 처음, 운영체제의 PCB가 생성이 되면 빈 스택과 빈 힙이 만들어 지는데 추후에 우리가 사용하는 프로그램의 프로세스는 처음 만들어진 0번 프로세스의 PCB를 fork() 함수를 통해 복사한다.
    - 이 프로세스들을 0번 프로세스의 자식 프로세스라고 한다.
    - 새로운 프로세스를 만들 때, 0번 프로세스를 fork()를 하는 이유는 프로세스를 새로 만드는것 보다 복사 하는것이 더 빠르기 때문이다.
- 이렇게 복사된 프로세스는 부모 프로세스의 PCB(정확히는 Heap을 제외한 코드, 데이터, 스택) + 프로그램 카운터를 그대로 가져온다.
- 자식 프로세스는 exec() 함수를 통해 그 주소공간(PCB)에 새로운 프로그램을 올린다.
- 유닉스의 예
    - fork()라는 시스템 콜이 새로운 프로세스를 생성
        - 부모 프로세스 주소공간을 그대로 복사(OS data except PID + binary) 후 할당
    - fork 시스템 콜 다음에 이어지는 exec() 시스템 콜을 통해 새로운 프로그램을 메모리에 올림
- 복사하는 fork()와 exec()은 같이 실행되어야 하는것은 아니다. 각각 실행되어 fork로 주소공간만 복사할 수 있고, exec()로 주소공간에 새로운 프로그램을 덮어씌워 메모리에 올릴수도 있다.
- 사용자 프로그램(프로세스)가 마음대로 복사하는것이 아니다. fork(), exec()은 시스템 콜이라고 했다. 즉, 운영체제에게 자식을 낳아달라고 부탁 해서 운영체제가 대신 자식 프로세스를 낳아주는 개념이라고 생각하면 된다.

## 🍎 프로세스의 종료
### 📖 정의
- 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌(exit)
    - exit()이라는 시스템 콜을 하면 프로세스가 종료된다.
- 프로세스가 종료될때 자식이 부모에게 data를 보낸다(wait() 시스템 콜을 통해서 data 전달)
    - 프로세스의 세계에서는 자식이 부모보다 먼저 종료된다.
- 프로세스의 각종 자원들이 운영체제에게 반납됨
### 📖 자발적 종료, 비자발적 종료
- 자발적으로 프로세스가 종료가 될때는 exit() 시스템콜을 해주고, 비 자발적으로 프로세스가 종료되는 경우는 abort라고 한다.
- 위에서 자발적으로 종료되는 경우를 다뤘으니 비자발적으로 종료되는 경우를 살펴보자.
- 즉, 부모 프로세스가 자식 프로세스를 종료 시키는 경우이다.
    - 자식이 할당 자원의 한계치를 넘어섬
        - 너무 많은 자원을 소모하면 종료시킴
    - 자식에게 할당된 테스크가 더 이상 필요하지 않음
        - 자식이 더 이상 필요없으면 종료시킴
    - 부모가 종료(exit)하는 경우
        - 운영체제는 부모 프로세스가 종료하는 경우 자식이 수행되도록 두지 않는다.
        - 프로세스 세계에서는 자식이 부모보다 먼저 종료되어야 한다고 했다. 하지만 어떤 경우에는 부모가 먼저 종료되는데 이때는 부모 프로세스를 통해 생성된 자식 프로세스(들)을 먼저 다 종료 시킨 후에 부모 프로세스가 종료된다.

## 🍎 쓰레드
### 📖 정의
- 개발자들은 왜 쓰레드를 만들었나?
    - 프로세스들 끼리 통신하는 IPC(Inter Process Communication)의 비용이 상대적으로 많이 들기 때문에 쓰레드라는 것을 만들었다.
- 프로세스 가장 작은 내부 실행 단위
- 프로세스 내에 존재하는것으로 최소 1개 유지
- Thread가 독립적으로 가지고 있는것 - CPU 수행과 관련된 정보
    - Program counter
    - Register set
    - Stack space
- Thread가 동료 thread와 공유하는 부분
    - task라고 부른다
    - Code section
    - Data section
    - OS resources

## 🍎 프로세스와 쓰레드의 장단점
- 프로세스의 장점 -> 안정성
    - 프로세스는 독립적이기 때문에 하나의 프로세스가 다른 프로세스에게 영향을 주지 않는다.
    - 반면, 쓰레드는 하나의 프로세스에서 코드, 데이터, OS 자원을 공유하고 있기 때문에 하나의 쓰레드에서 문제가 발생하면 다른 쓰레드까지 영향을 끼칠 수 있다.
- 프로세스의 단점 -> 속도와 자원
    - 각 프로세스는 서로 고유한 자원을 가지고있다.
    - 프로세스간 통신은 IPC를 통해서 해야하기 때문에 오버헤드가 크다.
    - 반면, 쓰레드는 스택 영역을 제외한 모든 영역을 공유하기 때문에 오버헤드가 굉장히 작다.
    - 쓰레드간의 통신은 데이터를 공유할 수 있으니 쉽게 할 수 있지만, 공유되는 공간에서 문제가 생길 수 있다.
